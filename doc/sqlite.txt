================================================================================
                                                                       *sqlinfo*

SQLite/LuaJIT binding and highly opinionated wrapper for storing, retrieving,
caching, persisting, querying, and connecting to SQLite databases.

To find out more visit https://github.com/tami5/sql.nvim

Help usage in neovim: ignore ||
  :h |sqlinfo|            | main sql.nvim classes
  :h |sqlite.schema.key|     | open a class or type
  :h |sqlite.tbl.overview|    | show help for sqlite.tbl.
  :h |sqlite.db.overview|     | show help for sqlite.tbl.
  :h sqlite.db:...            | show help for a sqlite.db method.
  :h sqlite.tbl:...           | show help for a sqlite.tbl method.

sql.nvim types:

sqlite : .db_status                                                   *sqlite*
    Status returned from |sqlite.db:status()|

    Parents: ~
        |.db_status|

    Fields: ~
        {msg} (string)


sqlite : .db_status                                                   *sqlite*
    Status returned from |sqlite.db:status()|

    Parents: ~
        |.db_status|

    Fields: ~
        {msg} (string)


sqlite : .db_status                                                   *sqlite*
    Status returned from |sqlite.db:status()|

    Parents: ~
        |.db_status|

    Fields: ~
        {msg} (string)


sqlite : .db_status                                                   *sqlite*
    Status returned from |sqlite.db:status()|

    Parents: ~
        |.db_status|

    Fields: ~
        {msg} (string)


sqlite : .db_status                                                   *sqlite*
    Status returned from |sqlite.db:status()|

    Parents: ~
        |.db_status|

    Fields: ~
        {msg} (string)


sqlite : .db_status                                                   *sqlite*
    Status returned from |sqlite.db:status()|

    Parents: ~
        |.db_status|

    Fields: ~
        {msg} (string)


sqlite : .db_status                                                   *sqlite*
    Status returned from |sqlite.db:status()|

    Parents: ~
        |.db_status|

    Fields: ~
        {msg} (string)


sqlite : .db_status                                                   *sqlite*
    Status returned from |sqlite.db:status()|

    Parents: ~
        |.db_status|

    Fields: ~
        {msg} (string)


sqlite : .db_status                                                   *sqlite*
    Status returned from |sqlite.db:status()|

    Parents: ~
        |.db_status|

    Fields: ~
        {msg} (string)



================================================================================
                                                            *sqlite.db.overview*

Main sql.nvim object and methods.

(optional) see |sqlite.db.opts|
---@return sqlite.db({uri})*(optional) see |sqlite.db.opts|
---@return sqlite.db()*
    Creates a new sql.nvim object, without creating a connection to uri.
    |sqlite.new| is identical to |sqlite:open| but it without opening sqlite db
    connection. Thus its most suited for cases where the database might be
    acccess from multiple places. For neovim use cases, this mean from
    different neovim instances.

    ```lua
    local db = sqlite.new("path/to/db" or "$env_var", { ... } or nil)
    ```


    Parameters: ~
        {uri} (string)  uri to db file.


(optional) see |sqlite.db.opts|
---@field tname1 string: pointing to |sqlite.etbl| or |sqlite.schema.dict|
---@field tnameN string: pointing to |sqlite.etbl| or |sqlite.schema.dict|
---@see sqlite.tbl:extend
---@return sqlite.db({opts})*(optional) see |sqlite.db.opts|
---@field tname1 string: pointing to |sqlite.etbl| or |sqlite.schema.dict|
---@field tnameN string: pointing to |sqlite.etbl| or |sqlite.schema.dict|
---@see sqlite.tbl:extend
---@return sqlite.db()*
    Extend |sqlite.db| object with extra sugar syntax and api. This is
    recommended for all sqlite use case as it provide convenience. This method
    is super lazy. it try its best to doing any ffi calls until the first
    operation done on a table.

    In the case you want to keep db connection open and not on invocation
    bases. Run |sqlite:open()| right after creating the object or when you
    intend,

    ```lua
    local db = sqlite { -- or sqlite.db:extend
      uri = "path/to/db", -- path to db file
      entries = entries,  -- pre-made |etbl| with |tbl:extend()| without db
      category = { title = { "text", unique = true, primary = true}  },
      opts = {} or nil -- custom sqlite3 options, see |sqlite.db.opts|
    }
    -- unlike |sqlite.tbl|, |sqlite.etbl| is accessed by dot notation.
    db.entries.insert { {..}, {..} }
    ```


    Parameters: ~
        {opts} (table)  see 'Fields'

    Fields: ~
        {uri} (string)  path to db file.


sqlite:close()                                                *sqlite:close()*
    Close sqlite db connection. returns true if closed, error otherwise.

    ```lua
    local db = sqlite:open()
    db:close() -- close connection
    ```


    Return: ~
        boolean


sqlite:with_open()                                        *sqlite:with_open()*
    Same as |sqlite:open| but execute {func} then closes db connection. If the
    function is called as a method to db object e.g. 'db:with_open', then
    {args[1]} must be a function. Else {args[1]} need to be the uri and
    {args[2]} the function.

    ```lua
    -- as a function
    local entries = sqlite.with_open("path/to/db", function(db)
       return db:select("todos", { where = { status = "done" } })
    end)
    -- as a method
    local exists = db:with_open(function()
      return db:exists("projects")
     end)
    ```



    Varargs: ~
        If used as db method, then the {args[1]} should be a function, else

    Return: ~
        any

    See: ~
        |sqlite:open()|


sqlite:isopen()                                              *sqlite:isopen()*
    Predict returning true if db connection is active.

    ```lua
    if db:isopen() then
      db:close()
    end
    ```


    Return: ~
        boolean


sqlite:isclose()                                            *sqlite:isclose()*
    Predict returning true if db connection is indeed closed.

    ```lua
    if db:isclose() then
      error("db is closed")
    end
    ```


    Return: ~
        boolean


sqlite:status()                                              *sqlite:status()*
    Returns current connection status Get last error code

    ```lua
    print(db:status().msg) -- get last error msg
    print(db:status().code) -- get last error code.
    ```


    Return: ~
        sqlite.db_status


sqlite:eval({statement}, {params})                             *sqlite:eval()*
    Evaluates a sql {statement} and if there are results from evaluation it
    returns list of rows. Otherwise it returns a boolean indecating whether the
    evaluation was successful.

    ```lua
    -- evaluate without any extra arguments.
    db:eval("drop table if exists todos")
    --  evaluate with unamed value.
    db:eval("select * from todos where id = ?", 1)
    -- evaluate with named arguments.
    db:eval("insert into t(a, b) values(:a, :b)", {a = "1", b = 3})
    ```


    Parameters: ~
        {statement} (string)     SQL statement.
        {params}    (table|nil)  params to be bind to {statement}

    Return: ~
        boolean|table


sqlite:execute({statement})                                 *sqlite:execute()*
    Execute statement without any return

    ```lua
    db:execute("drop table if exists todos")
    db:execute("pragma foreign_keys=on")
    ```


    Parameters: ~
        {statement} (string)  statement to be executed

    Return: ~
        boolean: true if successful, error out if not.


sqlite:exists({tbl_name})                                    *sqlite:exists()*
    Check if a table with {tbl_name} exists in sqlite db
    ```lua
    if not db:exists("todo_tbl") then
      error("Table doesn't exists!!!")
    end
    ```


    Parameters: ~
        {tbl_name} (string)  the table name.

    Return: ~
        boolean


sqlite:create({tbl_name})                                    *sqlite:create()*
    Create a new sqlite db table with {name} based on {schema}. if
    {schema.ensure} then create only when it does not exists. similar to
    'create if not exists'.

    ```lua
    db:create("todos", {
      id = {"int", "primary", "key"},
      title = "text",
      name = { type = "string", reference = "sometbl.id" },
      ensure = true -- create table if it doesn't already exists (THIS IS DEFUAULT)
    })
    ```


    Parameters: ~
        {tbl_name} (string)  table name

    Return: ~
        boolean


sqlite:drop({tbl_name})                                        *sqlite:drop()*
    Remove {tbl_name} from database

    ```lua
    if db:exists("todos") then
      db:drop("todos")
    end
    ```


    Parameters: ~
        {tbl_name} (string)  table name

    Return: ~
        boolean


sqlite:schema({tbl_name})                                    *sqlite:schema()*
    Get {name} table schema, if table does not exist then return an empty
    table.

    ```lua
    if db:exists("todos") then
      inspect(db:schema("todos").project)
    else
      print("create me")
    end
    ```


    Parameters: ~
        {tbl_name} (string)  the table name.

    Return: ~
        sqlite.schema.dict


sqlite:insert({tbl_name}, {rows})                            *sqlite:insert()*
    Insert lua table into sqlite database table.

    ```lua
    --- single item.
    db:insert("todos", { title = "new todo" })
    --- insert multiple items.
    db:insert("items", {  { name = "a"}, { name = "b" }, { name = "c" } })
    ```


    Parameters: ~
        {tbl_name} (string)  the table name
        {rows}     (table)   rows to insert to the table.

    Return: ~
        boolean|integer: boolean (true == success), and the last inserted row
        id.


sqlite:update({tbl_name}, {specs})                           *sqlite:update()*
    Update table row with where closure and list of values returns true incase
    the table was updated successfully.

    ```lua
    --- update todos status linked to project "lua-hello-world" or "rewrite-neoivm-in-rust"
    db:update("todos", {
      where = { project = {"lua-hello-world", "rewrite-neoivm-in-rust"} },
      set = { status = "later" }
    })

    --- pass custom statement and boolean
    db:update("timestamps", {
      where = { id = "<" .. 4 }, -- mimcs WHERE id < 4
      set = { seen = true } -- will be converted to 0.
    })
    ```


    Parameters: ~
        {tbl_name} (string)                                       sqlite table
                                                                  name.
        {specs}    (sqlite.update_query | sqlite.update_query[])

    Return: ~
        boolean


sqlite:delete({tbl_name})                                    *sqlite:delete()*
    Delete a {tbl_name} row/rows based on the {where} closure. If {where ==
    nil} then all the {tbl_name} content will be deleted.

    ```lua
    --- delete todos table content
    db:delete("todos")
    --- delete row that has id as 1
    db:delete("todos", { id = 1 })
    --- delete all rows that has value of id 1 or 2 or 3
    db:delete("todos", { id = {1,2,3} })
    --- matching ids or greater than 5
    db:delete("todos", { id = {"<", 5} }) -- or {id = "<5"}
    ```


    Parameters: ~
        {tbl_name} (string)  sqlite table name

    Return: ~
        boolean: true if operation is successfully, false otherwise.


sqlite:select({tbl_name}, {spec})                            *sqlite:select()*
    Query from a table with where and join options

    ```lua
    db:select("todos") get everything
    --- get row with id of 1
    db:select("todos", { where = { id = 1 })
    ---  get row with status value of later or paused
    db:select("todos", { where = { status = {"later", "paused"} })
    --- get 5 items from todos table
    db:select("todos", { limit = 5 })
    --- select a set of keys with computed one
    db:select("timestamps", {
      select = {
        age = (strftime("%s", "now") - strftime("%s", "timestamp")) * 24 * 60,
        "id",
        "timestamp",
        "entry",
        },
      })
    ```


    Parameters: ~
        {tbl_name} (string)                                  the name of the
                                                             db table to
                                                             select on
        {spec}     (sqlite.select_query
---@return table[])


sqlite:table({tbl_name}, {opts})                              *sqlite:table()*
    Create new sql-table object. If {opts}.ensure = false, on each run it will
    drop the table and recreate it.

    ```lua
    local tbl = db:table("todos", {
      id = true, -- { type = "integer", required = true, primary = true }
      title = "text",
      since = { "date", default = strftime("%s", "now") },
      count = { "number", default = 0 },
      type = { "text", required = true },
      category = {
        type = "text",
        reference = "category.id",
        on_update = "cascade", -- means when category get updated update
        on_delete = "null", -- means when category get deleted, set to null
      },
    })
    ```


    Parameters: ~
        {tbl_name} (string)  the name of the table. can be new or existing
                             one.
        {opts}     (table)   {schema, ensure (defalut true)}

    Return: ~
        sqlite.tbl


sqlite.lib()                                                    *sqlite.lib()*
    Sqlite functions sugar wrappers. See `sql/strfun`




================================================================================
                                                           *sqlite.tbl.overview*

Abstraction to produce more readable code.

tbl:new({name})                                                    *tbl:new()*
    Create new sql table object

    ```lua
    local tbl = tbl:new(db, "todos", {
      id = true, -- { type = "integer", required = true, primary = true }
      title = "text",
      since = { "date", default = strftime("%s", "now") },
      count = { "number", default = 0 },
      type = { "text", required = true },
      category = {
        type = "text",
        reference = "category.id",
        on_update = "cascade", -- means when category get updated update
        on_delete = "null", -- means when category get deleted, set to null
      },
    })
    ```


    Parameters: ~
        {name} (string)  table name

    Return: ~
        sqlite.tbl


tbl:extend({name})                                              *tbl:extend()*
    Same as |tbl:new()| but used to extend user defined object. This is the
    recommended way of constructing and using sqlite tables. The only
    difference between this and |tbl:new()| or |sqlite:table()| is the fact
    that all resulting methods are access using the dot notation '.', and when
    the user overwrites a tbl methods, it gets renamed to `_method_name`.

    if first argument is {name} then second should be {schema}. If no {db} is
    provided, the tbl object won't be initialized until 'tbl.set_db' is called,
    thus it can't be defined in different files.

    ```lua
    local t = tbl("entries", { ... } })
    t.insert {...} -- insert rows NOTICE: dot notation
    --- get all entries
    t.get()
    --- Overwrite method name and access original via t._get
    t.get = function() return t._get({ where = {...}, select = {...} })[1] end
    ```


    Parameters: ~
        {name} (string)

    Return: ~
        sqlite.etbl


tbl:schema()                                                    *tbl:schema()*
    Create or change table schema. If no {schema} is given, then it return
    current the used schema if it exists or empty table otherwise. On change
    schema it returns boolean indecting success.

    ```lua
    local projects = tbl:new("", {...})
    --- get project table schema.
    projects:schema() -- or 'project.schema()' dot notation with |tbl:extend|
    --- mutate project table schema with droping content if not schema.ensure
    projects:schema {...} -- or 'project.schema {...}' dot notation with |tbl:extend|
    ```


    Return: ~
        sqlite.schema.dict | boolean


tbl:drop()                                                        *tbl:drop()*
    Remove table from database, if the table is already drooped then it returns
    false.

    ```lua
    --- drop todos table content.
    todos:drop() or 'todos.drop()' -- dot notation for |tbl:extend|
    ```


    Return: ~
        boolean

    See: ~
        |sqlite:drop()|


tbl:empty()                                                      *tbl:empty()*
    Predicate that returns true if the table is empty.

    ```lua
    if todos:empty() then -- or 'todos.emtpy()' for |tbl:extend|
      print "no more todos, we are free :D"
    end
    ```


    Return: ~
        boolean


tbl:exists()                                                    *tbl:exists()*
    Predicate that returns true if the table exists.

    ```lua
    if goals:exists() then -- or 'goals.exists()' for |tbl:extend|
      error("I'm disappointed in you :D")
    end
    ```


    Return: ~
        boolean


tbl:count()                                                      *tbl:count()*
    Get the current number of rows in the table

    ```lua
    if notes:count() == 0 then -- or 'notes.counts()' for |tbl:extend|
      print("no more notes")
    end
    ```


    Return: ~
        number


tbl:get()                                                          *tbl:get()*
    Query the table and return results.

    ```lua
    --- get everything
    todos:get() -- or 'todos.get()' with |tbl:extend|
    --- get row with id of 1
    todos:get { where = { id = 1 } } -- or 'todos.get { ... }' with |tbl:extend|
    --- select a set of keys with computed one
    timestamps:get { -- or 'timestamps.get {... }'  with |tbl:extend|
      select = {
        age = (strftime("%s", "now") - strftime("%s", "timestamp")) * 24 * 60,
        "id",
        "timestamp",
        "entry",
        },
      }
    ```


    Return: ~
        table

    See: ~
        |sqlite:select()|


tbl:where({where})                                               *tbl:where()*
    Get first match.

    ```lua
    --- get single entry. notice that we don't pass where key.
    tbl:where{ id = 1 } -- or tbl.where()  with |tbl:extend|
    --- get row with id of 1 or 'todos.where { id = 1 }'
    ```


    Parameters: ~
        {where} (table)  where key values

    Return: ~
        nil or row

    Usage: ~
        ``

    See: ~
        |sqlite:select()|


tbl:each({func})                                                  *tbl:each()*
    Iterate over table rows and execute {func}. Returns false if no row is
    returned.

    ```lua
    --- Execute a function on each returned row
    todos:each(function(row)
      print(row.title)
    end, {
      where = { status = "pending" },
      contains = { title = "fix*" }
    })
    --- This works too. use 'todos.each(..)' with |tbl:extend|
    todos:each({ where = { ... }}, function(row)
      print(row.title)
    end)
    ```


    Parameters: ~
        {func} (function)  func(row)

    Return: ~
        boolean


tbl:map({func}, {query})                                           *tbl:map()*
    Create a new table from iterating over a tbl rows with {func}.

    ```lua
    --- transform rows. use todos.map(..) with |tbl:extend|
    local rows = todos:map(function(row)
      row.somekey = ""
      row.f = callfunction(row)
      return row
    end, {
      where = { status = "pending" },
      contains = { title = "fix*" }
    })
    --- This works too.
    local titles = todos:map({ where = { ... }}, function(row)
      return row.title
    end)
    --- no query, no problem :D
    local all = todos:map(function(row) return row.title end)
    ```


    Parameters: ~
        {func}  (function)    func(row)
        {query} (tblext|nil)

    Return: ~
        table[]


tbl:sort({transform}, {comp})                                     *tbl:sort()*
    Sorts a table in-place using a transform. Values are ranked in a custom
    order of the results of running `transform (v)` on all values. `transform`
    may also be a string name property sort by. `comp` is a comparison
    function. Adopted from Moses.lua

    ```lua
    --- return rows sort by id. t1.sort() with |tbl:extend|
    local res = t1:sort({ where = {id = {32,12,35}}})
    --- return rows sort by age
    local res = t1:sort({ where = {id = {32,12,35}}}, "age")`
    --- return with custom sort function (recommended)
    local res = t1:sort({where = { ... }}, "age", function(a, b) return a > b end)`
    ```


    Parameters: ~
        {transform} (function)  a `transform` function to sort elements.
                                Defaults to @{identity}
        {comp}      (function)  a comparison function, defaults to the `<`
                                operator

    Return: ~
        table[]


tbl:insert({rows})                                              *tbl:insert()*
    Insert rows into a table.

    ```lua
    --- single item.
    todos:insert { title = "new todo" }
    --- insert multiple items, using todos table as first param
    tbl.insert(todos, "items", {  { name = "a"}, { name = "b" }, { name = "c" } })
    --- insert with |tbl:extend|
    todos.insert { ... }
    ```


    Parameters: ~
        {rows} (table)  a row or a group of rows

    Return: ~
        integer: last inserted id

    Usage: ~
        `todos:insert { title = "stop writing examples :D" }` insert single
        item.
        `todos:insert { { ... }, { ... } }` insert multiple items

    See: ~
        |sqlite:insert()|


tbl:remove()                                                    *tbl:remove()*
    Delete a rows/row or table content based on {where} closure. If {where ==
    nil} then clear table content.

    ```lua
    --- delete todos table content
    todos:remove()
    --- delete row that has id as 1
    todos:remove { id = 1 }
    --- delete all rows that has value of id 1 or 2 or 3
    todos:remove { id = {1,2,3} }
    --- matching ids or greater than 5
    todos:remove { id = {"<", 5} } -- or {id = "<5"}
    --- with |sqtbl:extend|
    todos.remove {...}
    ```


    Return: ~
        boolean

    See: ~
        |sqlite:delete()|


tbl:update()                                                    *tbl:update()*
    Update table row with where closure and list of values returns true incase
    the table was updated successfully.

    ```lua
    --- update todos status linked to project "lua-hello-world" or "rewrite-neoivm-in-rust"
    todos:update { -- or 'todos.update { .. }' with |tbl:extend|
      where = { project = {"lua-hello-world", "rewrite-neoivm-in-rust"} },
      set = { status = "later" }
    }
    --- pass custom statement and boolean
    ts:update { -- or 'ts.update { .. }' with |tbl:extend|
      where = { id = "<" .. 4 }, -- mimcs WHERE id < 4
      set = { seen = true } -- will be converted to 0.
    }
    ```


    Return: ~
        boolean

    See: ~
        |sqlite:update()|
        |sqlite.update_query()|


tbl:replace({rows})                                            *tbl:replace()*
    Replaces table content with a given set of {rows}.

    ```lua
    --- replace project table content with a single call
    todos:replace { -- or 'todos.replace { ... }' with |tbl:extend|
      { ... },
      { ... },
      { ... },
    }
    --- replace everything with a single row
    ts:replace { -- or 'ts.replace { .. }' with |tbl:extend|
      key = "val"
    }
    ```


    Parameters: ~
        {rows} (table[]|table)

    Return: ~
        boolean

    See: ~
        |sqlite:delete()|
        |sqlite:insert()|



 vim:tw=78:ts=8:ft=help:norl:
