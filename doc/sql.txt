================================================================================
                                                                       *sql.lua*

SQLite/LuaJIT binding and highly opinionated wrapper for storing, retrieving,
caching, persisting, querying, and connecting to SQLite databases.
To find out more:
https://github.com/tami5/sql.nvim
  :h sql
  :h sql.table

DB.new({uri}, {opts})                                               *DB.new()*
    Creates a new sql.nvim object, without creating a connection to uri.
    |DB.new| is identical to |DB:open| but it without opening sqlite db
    connection.


    Parameters: ~
        {uri}  (string)  path to db.if nil, then create in memory database.
        {opts} (table)   sqlite db options see
                         https://www.sqlite.org/pragma.html

    Return: ~
        SQLDatabase

    Usage: ~
        `require'sql'.new()` in memory
        `require'sql'.new("./path/to/sql.sqlite")` to given path
        `require'sql'.new("$ENV_VARABLE")` reading from env variable

    See: ~
        |DB:open()|


DB:open({uri}, {opts})                                             *DB:open()*
    Connect, or create new sqlite db, either in memory or via a {uri}.
    |DB:open| is identical to |DB.new| but it additionally opens the db


    Parameters: ~
        {uri}  (string)  if uri is nil, then create in memory database.
        {opts} (table)   

    Return: ~
        SQLDatabase

    Usage: ~
        `require("sql"):open()` in memory.
        `require("sql"):open("./path/to/sql.sqlite")` to given path.
        `require("sql"):open("$ENV_VARABLE")` reading from env variable
        `db:open()` reopen connection if closed.


DB:close()                                                        *DB:close()*
    Close sqlite db connection. returns true if closed, error otherwise.


    Return: ~
        boolean

    Usage: ~
        `db:close()`


DB:with_open()                                                *DB:with_open()*
    Same as |DB:open| but closes db connection after executing {args[1]} or
    {args[2]} depending of how its called. if the function is called as a
    method to db object e.g. *db:with_open*, then {args[1]} must be a function.
    Else {args[1]} need to be the uri and {args[2]} the function. The function
    should accept and use db object.


    Varargs: ~
        If used as db method, then the {args[1]} should be a function, else
        {args[1]} and {args[2]}.

    Return: ~
        any

    Usage: ~
        `require"sql".open_with("path", function(db) db:eval("...") end)` use
        a the sqlite db at path.
        `db:with_open(function() db:insert{...} end)` open db connection,
        execute insert and close.

    See: ~
        |DB:open()|


DB:isopen()                                                      *DB:isopen()*
    Predict returning true if db connection is active.


    Return: ~
        boolean

    Usage: ~
        `if db:isopen() then db:close() end` use in if statement.


DB:isclose()                                                    *DB:isclose()*
    Predict returning true if db connection is indeed closed.


    Return: ~
        boolean

    Usage: ~
        `if db:isclose() then db:open() end` use in if statement.


DB:status()                                                      *DB:status()*
    Returns current connection status Get last error code



DB:eval({statement}, {params})                                     *DB:eval()*
    Evaluates a sql {statement} and if there are results from evaluating it
    then the function returns list of row(s). Else, it returns a boolean
    indecating whether the evaluation was successful. Optionally, the function
    accept {params} which can be a dict of values corresponding to the sql
    statement or a list of unamed values.


    Parameters: ~
        {statement} (any)    string representing the {statement} or a list of
                             {statements}
        {params}    (table)  params to be bind to {statement}, it can be a
                             list or dict or nil

    Return: ~
        boolean | table

    Usage: ~
        `db:eval("drop table if exists todos")` evaluate without any extra
        arguments.
        `db:eval("select * from todos where id = ?", 1)` evaluate with unamed
        value.
        `db:eval("insert into t(a, b) values(:a, :b)", {a = "1", b = 3})`
        evaluate with named arguments.


DB:exists({tbl_name})                                            *DB:exists()*
    Check if a table with {tbl_name} exists in sqlite db


    Parameters: ~
        {tbl_name} (string)  the table name.

    Return: ~
        boolean

    Usage: ~
        `if not db:exists("todo_tbl") then error("...") end`


DB:create({tbl_name}, {schema})                                  *DB:create()*
    Create a new sqlite db table with {name} based on {schema}. if
    {schema.ensure} then create only when it does not exists. similar to
    'create if not exists'.


    Parameters: ~
        {tbl_name} (string)  table name
        {schema}   (table)   the table keys/column and their types

    Return: ~
        boolean

    Usage: ~
        `db:create("todos", {id = {"int", "primary", "key"}, title = "text"})`
        create table with the given schema.


DB:drop({tbl_name})                                                *DB:drop()*
    Remove {tbl_name} from database


    Parameters: ~
        {tbl_name} (string)  table name

    Return: ~
        boolean

    Usage: ~
        `db:drop("todos")` drop table.


DB:schema({tbl_name}, {info})                                    *DB:schema()*
    Get {name} table schema, if table does not exist then return an empty
    table.


    Parameters: ~
        {tbl_name} (string)   the table name.
        {info}     (boolean)  whether to return table info. default false.

    Return: ~
        table list of keys or keys and their type.


DB:insert({tbl_name}, {rows})                                    *DB:insert()*
    Insert to lua table into sqlite database table. returns true incase the
    table was inserted successfully, and the last inserted row id.


    Parameters: ~
        {tbl_name} (string)  the table name
        {rows}     (table)   rows to insert to the table.

    Return: ~
        boolean|integer

    Usage: ~
        `db:insert("todos", { title = "new todo" })` single item.
        `db:insert("items", { { name = "a"}, { name = "b" }, { name = "c" }
        })` insert multiple items.


DB:update({tbl_name}, {specs})                                   *DB:update()*
    Update table row with where closure and list of values returns true incase
    the table was updated successfully.


    Parameters: ~
        {tbl_name} (string)                       the name of the db table.
        {specs}    (SQLQuerySpec|SQLQuerySpec[])  

    Return: ~
        boolean

    Usage: ~
        `db:update("todos", { where = { id = "1" }, values = { action = "DONE"
        }})` update id 1 with the given keys
        `db:update("todos", {{ where = { id = "1" }, values = { action =
        "DONE" }}, {...}, {...}})` multi updates.
        `db:update("todos", { where = { project = "sql.nvim" }, values = {
        status = "later" } )` update multiple rows


DB:delete({tbl_name}, {specs})                                   *DB:delete()*
    Delete a {tbl_name} row/rows based on the {specs} given. if no spec was
    given, then all the {tbl_name} content will be deleted.


    Parameters: ~
        {tbl_name} (string)        the name of the db table.
        {specs}    (SQLQuerySpec)  

    Return: ~
        boolean: true if operation is successfully, false otherwise.

    Usage: ~
        `db:delete("todos")` delete todos table content
        `db:delete("todos", { where = { id = 1 })` delete row that has id as 1
        `db:delete("todos", { where = { id = {1,2,3} })` delete all rows that
        has value of id 1 or 2 or 3


DB:select({tbl_name}, {spec})                                    *DB:select()*
    Query from a table with where and join options


    Parameters: ~
        {tbl_name} (string)        the name of the db table to select on
        {spec}     (SQLQuerySpec)  

    Return: ~
        table[]

    Usage: ~
        `db:select("todos")` get everything
        `db:select("todos", { where = { id = 1 })` get row with id of 1
        `db:select("todos", { where = { status = {"later", "paused"} })` get
        row with status value of later or paused
        `db:select("todos", { limit = 5 })` get 5 items from todos table


DB:table({tbl_name}, {opts})                                      *DB:table()*
    Create new sql-table object. If {opts}.ensure = false, on each run it will
    drop the table and recreate it.


    Parameters: ~
        {tbl_name} (string)  the name of the table. can be new or existing
                             one.
        {opts}     (table)   {schema, ensure (defalut true)}

    Return: ~
        SQLTable



================================================================================
tbl:new({db}, {opts})                                              *tbl:new()*
    Create new sql table object


    Parameters: ~
        {db}   (SQLDatabase)   
        {opts} (SQLTableOpts)  

    Return: ~
        SQLTable


tbl:schema({schema})                                            *tbl:schema()*
    Create or change table schema. If no {schema} is given, then it return
    current the used schema if it exists or empty table otherwise. On change
    schema it returns boolean indecting success.


    Parameters: ~
        {schema} (table)  table schema definition

    Return: ~
        table table | boolean

    Usage: ~
        `projects:schema()` get project table schema.
        `projects:schema({...})` mutate project table schema


tbl:drop()                                                        *tbl:drop()*
    Remove table from database, if the table is already drooped then it returns
    false.


    Return: ~
        boolean

    Usage: ~
        `todos:drop()` drop todos table content.

    See: ~
        |DB:drop()|


tbl:empty()                                                      *tbl:empty()*
    Predicate that returns true if the table is empty.


    Return: ~
        boolean

    Usage: ~
        `if todos:empty() then echo "no more todos, you are free :D" end`


tbl:exists()                                                    *tbl:exists()*
    Predicate that returns true if the table exists.


    Return: ~
        boolean

    Usage: ~
        `if not goals:exists() then error("I'm disappointed in you ") end`


tbl:count()                                                      *tbl:count()*
    Get the current number of rows in the table


    Return: ~
        number


tbl:get({query})                                                   *tbl:get()*
    Query the table and return results. If cache is enabled and the {query} has
    been ran before, then query results from cache will be returned. Returns
    empty table if no results


    Parameters: ~
        {query} (table)  query.where, query.keys, query.join

    Return: ~
        table

    Usage: ~
        `projects:get()` get a list of all rows in project table.
        `projects:get({ where = { status = "pending", client = "neovim" }})`
        `projects:get({ where = { status = "done" }, limit = 5})` get the last
        5 done projects

    See: ~
        |DB:select()|


tbl:where({where})                                               *tbl:where()*
    Get first match. If cache is enabled and the {query} has been ran before,
    then query results from cache will be returned.


    Parameters: ~
        {where} (table)  where key values

    Return: ~
        nil or row

    Usage: ~
        `tbl:where{id = 1}`

    See: ~
        |DB:select()|


tbl:each({query}, {func})                                         *tbl:each()*
    Iterate over table rows and execute {func}. Returns true only when rows is
    not emtpy.


    Parameters: ~
        {query} (table)     query.where, query.keys, query.join
        {func}  (function)  func(row)

    Return: ~
        boolean

    Usage: ~
        `let query = { where = { status = "pending"}, contains = { title =
        "fix*" } }`
        `todos:each(query, function(row) print(row.title) end)`


tbl:map({query}, {func})                                           *tbl:map()*
    Create a new table from iterating over {self.name} rows with {func}.


    Parameters: ~
        {query} (table)     query.where, query.keys, query.join
        {func}  (function)  a function that expects a row

    Return: ~
        table[]

    Usage: ~
        `let query = { where = { status = "pending"}, contains = { title =
        "fix*" } }`
        `local t = todos:map(query, function(row) return row.title end)`


tbl:sort({query}, {transform}, {comp})                            *tbl:sort()*
    Sorts a table in-place using a transform. Values are ranked in a custom
    order of the results of running `transform (v)` on all values. `transform`
    may also be a string name property sort by. `comp` is a comparison
    function. Adopted from Moses.lua


    Parameters: ~
        {query}     (table)     query.where, query.keys, query.join
        {transform} (function)  a `transform` function to sort elements.
                                Defaults to @{identity}
        {comp}      (function)  a comparison function, defaults to the `<`
                                operator

    Return: ~
        table[]

    Usage: ~
        `local res = t1:sort({ where = {id = {32,12,35}}})` return rows sort
        by id
        `local res = t1:sort({ where = {id = {32,12,35}}}, "age")` return rows
        sort by age
        `local res = t1:sort({where = {id = { 32,12,35 }}}, "age", function(a,
        b) return a > b end)` with custom function


tbl:insert({rows})                                              *tbl:insert()*
    Same functionalities as |DB:insert()|


    Parameters: ~
        {rows} (table)  a row or a group of rows

    Return: ~
        boolean|integer

    Usage: ~
        `todos:insert { title = "stop writing examples :D" }` insert single
        item.
        `todos:insert { { ... }, { ... } }` insert multiple items

    See: ~
        |DB:insert()|


tbl:remove({where})                                             *tbl:remove()*
    Same functionalities as |DB:delete()|


    Parameters: ~
        {where} (table)  query

    Return: ~
        boolean

    Usage: ~
        `todos:remove()` remove todos table content.
        `todos:insert{ project = "neovim" }` remove all todos where project ==
        "neovim".

    See: ~
        |DB:delete()|


tbl:update({specs})                                             *tbl:update()*
    Same functionalities as |DB:update()|


    Parameters: ~
        {specs} (table)  a table or a list of tables with where and values
                         keys.

    Return: ~
        boolean

    See: ~
        |DB:update()|


tbl:replace({rows})                                            *tbl:replace()*
    replaces table content with {rows}


    Parameters: ~
        {rows} (table)  a row or a group of rows

    Return: ~
        boolean

    See: ~
        |DB:delete()|
        |DB:insert()|



 vim:tw=78:ts=8:ft=help:norl:
