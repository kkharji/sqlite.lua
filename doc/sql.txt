================================================================================
                                                                       *sql.lua*

SQLite/LuaJIT binding and highly opinionated wrapper for storing, retrieving,
caching, persisting, querying, and connecting to SQLite databases.
To find out more:
https://github.com/tami5/sql.nvim
  :h sql
  :h sql.table

SQLDatabase                                                      *SQLDatabase*
    Main sql.nvim object.

    Fields: ~
        {uri}  (string)        database uri
        {conn} (sqlite3_blob)  sqlite connection c object.


SqlSchemaKeyDefinition                                *SqlSchemaKeyDefinition*


    Fields: ~
        {cid}       (number)         column index
        {name}      (string)         column key
        {type}      (string)         column type
        {required}  (boolean)        whether the column key is required or not
        {primary}   (boolean)        whether the column is a primary key
        {default}   (string)         the default value of the column
        {reference} (string)         table_name.column
        {on_update} (SqliteActions)  what to do when the key gets updated
        {on_delete} (SqliteActions)  what to do when the key gets deleted


SQLQuerySpec                                                    *SQLQuerySpec*
    Query spec that are passed to a number of db: methods.

    Fields: ~
        {where}  (table)  key and value
        {values} (table)  key and value to updated.


SQLDatabaseExt : SQLDatabase                                  *SQLDatabaseExt*
    Extend sql.nvim object

    Parents: ~
        |SQLDatabase|

    Fields: ~
        {db} (SQLDatabase)  fallback when the user overwrite @SQLDatabaseExt
                            methods.


SQLDatabaseStatus                                          *SQLDatabaseStatus*


    Fields: ~
        {msg}  (string)
        {code} (sqlite3_flag)


DB.new({uri}, {opts})                                               *DB.new()*
    Creates a new sql.nvim object, without creating a connection to uri.
    |DB.new| is identical to |DB:open| but it without opening sqlite db
    connection.


    Parameters: ~
        {uri}  (string)  path to db.if nil, then create in memory database.
        {opts} (table)   sqlite db options see
                         https://www.sqlite.org/pragma.html

    Return: ~
        SQLDatabase

    Usage: ~
        `require'sql'.new()` in memory
        `require'sql'.new("./path/to/sql.sqlite")` to given path
        `require'sql'.new("$ENV_VARABLE")` reading from env variable

    See: ~
        |DB:open()|


DB:open({uri}, {opts})                                             *DB:open()*
    Connect, or create new sqlite db, either in memory or via a {uri}.
    |DB:open| is identical to |DB.new| but it additionally opens the db


    Parameters: ~
        {uri}  (string)  if uri is nil, then create in memory database.
        {opts} (table)

    Return: ~
        SQLDatabase

    Usage: ~
        `require("sql"):open()` in memory.
        `require("sql"):open("./path/to/sql.sqlite")` to given path.
        `require("sql"):open("$ENV_VARABLE")` reading from env variable
        `db:open()` reopen connection if closed.


DB:extend({sql}, {tbl}, {opts})                                  *DB:extend()*
    Use to Extend SQLDatabase Object with extra sugar syntax and api.


    Parameters: ~
        {sql}  (SQLDatabase)
        {tbl}  (SQLTable)
        {opts} (table)        uri, init, opts, tbl_name, tbl_name ....

    Return: ~
        SQLDatabaseExt

    Usage: ~
        `local tbl = require('sql.table'):extend("tasks", { ... })` --
        pre-made table
        `local tbl = { ... }` -- normal schema table schema
        `local tbl = { _name = "tasks", ... }` -- normal table with schema and
        custom table name
        `local db = DB:extend { uri = "", t = tbl }` -- db.t to access sql
        'tbl' object.
        `db.t.insert {...}; db.t.get(); db.t.remove(); db:isopen()`


DB:close()                                                        *DB:close()*
    Close sqlite db connection. returns true if closed, error otherwise.


    Return: ~
        boolean

    Usage: ~
        `db:close()`


DB:with_open()                                                *DB:with_open()*
    Same as |DB:open| but closes db connection after executing {args[1]} or
    {args[2]} depending of how its called. if the function is called as a
    method to db object e.g. *db:with_open*, then {args[1]} must be a function.
    Else {args[1]} need to be the uri and {args[2]} the function. The function
    should accept and use db object.


    Varargs: ~
        If used as db method, then the {args[1]} should be a function, else
        {args[1]} and {args[2]}.

    Return: ~
        any

    Usage: ~
        `require"sql".open_with("path", function(db) db:eval("...") end)` use
        a the sqlite db at path.
        `db:with_open(function() db:insert{...} end)` open db connection,
        execute insert and close.

    See: ~
        |DB:open()|


DB:isopen()                                                      *DB:isopen()*
    Predict returning true if db connection is active.


    Return: ~
        boolean

    Usage: ~
        `if db:isopen() then db:close() end` use in if statement.


DB:isclose()                                                    *DB:isclose()*
    Predict returning true if db connection is indeed closed.


    Return: ~
        boolean

    Usage: ~
        `if db:isclose() then db:open() end` use in if statement.


DB:status()                                                      *DB:status()*
    Returns current connection status Get last error code


    Return: ~
        SQLDatabaseStatus


DB:eval({statement}, {params})                                     *DB:eval()*
    Evaluates a sql {statement} and if there are results from evaluating it
    then the function returns list of row(s). Else, it returns a boolean
    indecating whether the evaluation was successful. Optionally, the function
    accept {params} which can be a dict of values corresponding to the sql
    statement or a list of unamed values.


    Parameters: ~
        {statement} (any)    string representing the {statement} or a list of
                             {statements}
        {params}    (table)  params to be bind to {statement}, it can be a
                             list or dict or nil

    Return: ~
        boolean | table

    Usage: ~
        `db:eval("drop table if exists todos")` evaluate without any extra
        arguments.
        `db:eval("select * from todos where id = ?", 1)` evaluate with unamed
        value.
        `db:eval("insert into t(a, b) values(:a, :b)", {a = "1", b = 3})`
        evaluate with named arguments.


DB:execute({statement})                                         *DB:execute()*
    Execute statement without any return


    Parameters: ~
        {statement} (string)  statement to be executed

    Return: ~
        boolean: true if successful, error out if not.


DB:exists({tbl_name})                                            *DB:exists()*
    Check if a table with {tbl_name} exists in sqlite db


    Parameters: ~
        {tbl_name} (string)  the table name.

    Return: ~
        boolean

    Usage: ~
        `if not db:exists("todo_tbl") then error("...") end`


DB:create({tbl_name}, {schema})                                  *DB:create()*
    Create a new sqlite db table with {name} based on {schema}. if
    {schema.ensure} then create only when it does not exists. similar to
    'create if not exists'.


    Parameters: ~
        {tbl_name} (string)                                 table name
        {schema}   (table<string, SqlSchemaKeyDefinition>)

    Return: ~
        boolean

    Usage: ~
        `db:create("todos", {id = {"int", "primary", "key"}, title = "text"})`
        create table with the given schema.


DB:drop({tbl_name})                                                *DB:drop()*
    Remove {tbl_name} from database


    Parameters: ~
        {tbl_name} (string)  table name

    Return: ~
        boolean

    Usage: ~
        `db:drop("todos")` drop table.


DB:schema({tbl_name})                                            *DB:schema()*
    Get {name} table schema, if table does not exist then return an empty
    table.


    Parameters: ~
        {tbl_name} (string)  the table name.

    Return: ~
        table<string, SqlSchemaKeyDefinition>


DB:insert({tbl_name}, {rows})                                    *DB:insert()*
    Insert to lua table into sqlite database table. returns true incase the
    table was inserted successfully, and the last inserted row id.


    Parameters: ~
        {tbl_name} (string)  the table name
        {rows}     (table)   rows to insert to the table.

    Return: ~
        boolean|integer

    Usage: ~
        `db:insert("todos", { title = "new todo" })` single item.
        `db:insert("items", { { name = "a"}, { name = "b" }, { name = "c" }
        })` insert multiple items.


DB:update({tbl_name}, {specs})                                   *DB:update()*
    Update table row with where closure and list of values returns true incase
    the table was updated successfully.


    Parameters: ~
        {tbl_name} (string)                       the name of the db table.
        {specs}    (SQLQuerySpec|SQLQuerySpec[])

    Return: ~
        boolean

    Usage: ~
        `db:update("todos", { where = { id = "1" }, values = { action = "DONE"
        }})` update id 1 with the given keys
        `db:update("todos", {{ where = { id = "1" }, values = { action =
        "DONE" }}, {...}, {...}})` multi updates.
        `db:update("todos", { where = { project = "sql.nvim" }, values = {
        status = "later" } )` update multiple rows


DB:delete({tbl_name}, {where})                                   *DB:delete()*
    Delete a {tbl_name} row/rows based on the {specs} given. if no spec was
    given, then all the {tbl_name} content will be deleted.


    Parameters: ~
        {tbl_name} (string)  the name of the db table.
        {where}    (table)   keys and their values

    Return: ~
        boolean: true if operation is successfully, false otherwise.

    Usage: ~
        `db:delete("todos")` delete todos table content
        `db:delete("todos", { id = 1 })` delete row that has id as 1
        `db:delete("todos", { id = {1,2,3} })` delete all rows that has value
        of id 1 or 2 or 3
        `db:delete("todos", { id = {1,2,3} }, { id = {"<", 5} } )` matching
        ids or greater than 5


DB:select({tbl_name}, {spec})                                    *DB:select()*
    Query from a table with where and join options


    Parameters: ~
        {tbl_name} (string)        the name of the db table to select on
        {spec}     (SQLQuerySpec)

    Return: ~
        table[]

    Usage: ~
        `db:select("todos")` get everything
        `db:select("todos", { where = { id = 1 })` get row with id of 1
        `db:select("todos", { where = { status = {"later", "paused"} })` get
        row with status value of later or paused
        `db:select("todos", { limit = 5 })` get 5 items from todos table


DB:table({tbl_name}, {opts})                                      *DB:table()*
    Create new sql-table object. If {opts}.ensure = false, on each run it will
    drop the table and recreate it.


    Parameters: ~
        {tbl_name} (string)  the name of the table. can be new or existing
                             one.
        {opts}     (table)   {schema, ensure (defalut true)}

    Return: ~
        SQLTable


DB.lib()                                                            *DB.lib()*
    Sqlite functions sugar wrappers. See `sql/strfun`




================================================================================
                                                                     *table.lua*

Abstraction to produce more readable code.

SQLTable                                                            *SQLTable*
    Main table class

    Fields: ~
        {db} (SQLDatabase)  database in which the tbl is part of.


tbl:new({db}, {name}, {schema})                                    *tbl:new()*
    Create new sql table object


    Parameters: ~
        {db}     (SQLDatabase)
        {name}   (string)                                 table name
        {schema} (table<string, SqlSchemaKeyDefinition>)

    Return: ~
        SQLTable


tbl:extend({db}, {name}, {schema})                              *tbl:extend()*
    Extend Sqlite Table Object. if first argument is {name} then second should
    be {schema}. If no {db} is provided, the tbl object won't be initialized
    until tbl.set_db is called


    Parameters: ~
        {db}     (SQLDatabase)
        {name}   (string)
        {schema} (table<string, SqlSchemaKeyDefinition>)

    Return: ~
        SQLTableExt


tbl:schema({schema})                                            *tbl:schema()*
    Create or change table schema. If no {schema} is given, then it return
    current the used schema if it exists or empty table otherwise. On change
    schema it returns boolean indecting success.


    Parameters: ~
        {schema} (table<string, SqlSchemaKeyDefinition>)

    Return: ~
        table<string, SqlSchemaKeyDefinition> | boolean

    Usage: ~
        `projects:schema()` get project table schema.
        `projects:schema({...})` mutate project table schema


tbl:drop()                                                        *tbl:drop()*
    Remove table from database, if the table is already drooped then it returns
    false.


    Return: ~
        boolean

    Usage: ~
        `todos:drop()` drop todos table content.

    See: ~
        |DB:drop()|


tbl:empty()                                                      *tbl:empty()*
    Predicate that returns true if the table is empty.


    Return: ~
        boolean

    Usage: ~
        `if todos:empty() then echo "no more todos, you are free :D" end`


tbl:exists()                                                    *tbl:exists()*
    Predicate that returns true if the table exists.


    Return: ~
        boolean

    Usage: ~
        `if not goals:exists() then error("I'm disappointed in you ") end`


tbl:count()                                                      *tbl:count()*
    Get the current number of rows in the table


    Return: ~
        number


tbl:get({query})                                                   *tbl:get()*
    Query the table and return results.


    Parameters: ~
        {query} (table)  query.where, query.keys, query.join

    Return: ~
        table

    Usage: ~
        `projects:get()` get a list of all rows in project table.
        `projects:get({ where = { status = "pending", client = "neovim" }})`
        `projects:get({ where = { status = "done" }, limit = 5})` get the last
        5 done projects

    See: ~
        |DB:select()|


tbl:where({where})                                               *tbl:where()*
    Get first match.


    Parameters: ~
        {where} (table)  where key values

    Return: ~
        nil or row

    Usage: ~
        `tbl:where{id = 1}`

    See: ~
        |DB:select()|


tbl:each({func}, {query})                                         *tbl:each()*
    Iterate over table rows and execute {func}. Returns true only when rows is
    not emtpy.


    Parameters: ~
        {func}  (function)  func(row)
        {query} (table)     query.where, query.keys, query.join

    Return: ~
        boolean

    Usage: ~
        `let query = { where = { status = "pending"}, contains = { title =
        "fix*" } }`
        `todos:each(function(row) print(row.title) end, query)`


tbl:map({func}, {query})                                           *tbl:map()*
    Create a new table from iterating over {self.name} rows with {func}.


    Parameters: ~
        {func}  (function)  func(row)
        {query} (table)     query.where, query.keys, query.join

    Return: ~
        table[]

    Usage: ~
        `let query = { where = { status = "pending"}, contains = { title =
        "fix*" } }`
        `local t = todos:map(function(row) return row.title end, query)`


tbl:sort({query}, {transform}, {comp})                            *tbl:sort()*
    Sorts a table in-place using a transform. Values are ranked in a custom
    order of the results of running `transform (v)` on all values. `transform`
    may also be a string name property sort by. `comp` is a comparison
    function. Adopted from Moses.lua


    Parameters: ~
        {query}     (table)     query.where, query.keys, query.join
        {transform} (function)  a `transform` function to sort elements.
                                Defaults to @{identity}
        {comp}      (function)  a comparison function, defaults to the `<`
                                operator

    Return: ~
        table[]

    Usage: ~
        `local res = t1:sort({ where = {id = {32,12,35}}})` return rows sort
        by id
        `local res = t1:sort({ where = {id = {32,12,35}}}, "age")` return rows
        sort by age
        `local res = t1:sort({where = { ... }}, "age", function(a, b) return a
        > b end)` with custom function


tbl:insert({rows})                                              *tbl:insert()*
    Same functionalities as |DB:insert()|


    Parameters: ~
        {rows} (table)  a row or a group of rows

    Return: ~
        integer: last inserted id

    Usage: ~
        `todos:insert { title = "stop writing examples :D" }` insert single
        item.
        `todos:insert { { ... }, { ... } }` insert multiple items

    See: ~
        |DB:insert()|


tbl:remove({where})                                             *tbl:remove()*
    Same functionalities as |DB:delete()|


    Parameters: ~
        {where} (table)  query

    Return: ~
        boolean

    Usage: ~
        `todos:remove()` remove todos table content.
        `todos:remove{ project = "neovim" }` remove all todos where project ==
        "neovim".
        `todos:remove{{project = "neovim"}, {id = 1}}` remove all todos where
        project == "neovim" or id =1

    See: ~
        |DB:delete()|


tbl:update({specs})                                             *tbl:update()*
    Same functionalities as |DB:update()|


    Parameters: ~
        {specs} (table)  a table or a list of tables with where and values
                         keys.

    Return: ~
        boolean

    See: ~
        |DB:update()|


tbl:replace({rows})                                            *tbl:replace()*
    replaces table content with {rows}


    Parameters: ~
        {rows} (table)  a row or a group of rows

    Return: ~
        boolean

    See: ~
        |DB:delete()|
        |DB:insert()|



 vim:tw=78:ts=8:ft=help:norl:
