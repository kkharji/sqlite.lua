================================================================================
                                                                        *readme*

SQLite/LuaJIT binding and highly opinionated wrapper for storing, retrieving,
caching, persisting, querying, and connecting to SQLite databases.

To find out more visit https://github.com/tami5/sqlite.lua

Help usage in neovim: ignore ||
  :h |readme|                | open readme.md
  :h |sqlite_schema_key|     | open a class or type
  :h |sqlite.tbl|            | show help for sqlite_tbl.
  :h |sqlite.db|             | show help for sqlite_tbl.
  :h sqlite.db:...           | show help for a sqlite_db method.
  :h sqlite.tbl:...          | show help for a sqlite_tbl method.

sqlite.lua types:

sqlite_db                                                          *sqlite_db*
    Main sqlite.lua object.

    Fields: ~
        {uri}  (string)       database uri. it can be an environment variable
                              or an absolute path. default ":memory:"
        {opts} (sqlite_opts)  see https://www.sqlite.org/pragma.html
                              |sqlite_opts|
        {conn} (sqlite_blob)  sqlite connection c object.
        {db}   (sqlite_db)    reference to fallback to when overwriting
                              |sqlite_db| methods (extended only).


sqlite_tbl                                                        *sqlite_tbl*
    Main sql table class

    Fields: ~
        {db}    (sqlite_db)  sqlite.lua database object.
        {name}  (string)     table name.
        {mtime} (number)     db last modified time.


sqlite_tblext                                                  *sqlite_tblext*
    Extended version of sql table class. This class is generated through
    |sqlite_tbl:extend|

    Fields: ~
        {db}    (sqlite_db)  sqlite.lua database object.
        {name}  (string)     table name
        {mtime} (number)     db last modified time


sqlite_schema_key                                          *sqlite_schema_key*
    Sqlite schema key fileds. {name} is the only required field.

    Fields: ~
        {cid}       (number)                 column index.
        {name}      (string)                 column key.
        {type}      (string)                 column type.
        {required}  (boolean)                whether it's required.
        {primary}   (boolean)                whether it's a primary key.
        {default}   (string)                 default value when null.
        {reference} (string)
        {on_delete} (sqlite_trigger)         trigger on row delete.
        {on_update} (table<string, string>)


sqlite_opts                                                      *sqlite_opts*
    Sqlite3 Options (TODO: add sqlite option fields and description)


sqlite_query_update                                      *sqlite_query_update*
    Query fileds used when calling |sqlite:update| or |sqlite_tbl:update|

    Fields: ~
        {where} (table)  filter down values using key values.
        {set}   (table)  key and value to updated.


sqlite_query_select                                      *sqlite_query_select*
    Query fileds used when calling |sqlite:select| or |sqlite_tbl:get|

    Fields: ~
        {where}    (table)   filter down values using key values.
        {keys}     (table)   keys to include. (default all)
        {join}     (table)   (TODO: support)
        {order_by} (table)   { asc = "key", dsc = {"key", "another_key"} }
        {limit}    (number)  the number of result to limit by
        {contains} (table)   for sqlite glob ex. { title = "fix*" }


sqlite_flags                                                    *sqlite_flags*
    Sqlite3 Error Flags (TODO: add sqlite error flags value and description)


sqlite_db_status                                            *sqlite_db_status*
    Status returned from |sqlite:status()|

    Fields: ~
        {msg}  (string)
        {code} (sqlite_flags)



================================================================================
                                                                     *sqlite.db*

Main sqlite.lua object and methods.

sqlite.db.new({uri}, {opts})                                 *sqlite.db.new()*
    Creates a new sqlite.lua object, without creating a connection to uri.
    |sqlite.new| is identical to |sqlite.db:open| but it without opening sqlite
    db connection. Thus its most suited for cases where the database might be
    acccess from multiple places. For neovim use cases, this mean from
    different neovim instances.

    ```lua
    local db = sqlite.new("path/to/db" or "$env_var", { ... } or nil)
    ```


    Parameters: ~
        {uri}  (string)       uri to db file.
        {opts} (sqlite_opts)  (optional) see |sqlite_opts|

    Return: ~
        sqlite_db


sqlite.db:open({uri}, {opts})                               *sqlite.db:open()*
    Creates and connect to new sqlite db object, either in memory or via a
    {uri}. If it is called on pre-made |sqlite_db| object, than it should open
    it. otherwise ignore.

    ```lua
    -- Open db file at path or environment variable, otherwise open in memory.
    local db = sqlite.db:open("./pathto/dbfile" or "$ENV_VARABLE" or nil, {...})
    -- reopen connection if closed.
    db:open()
    ```


    Parameters: ~
        {uri}  (string)           (optional) {uri} == {nil} then in-memory db.
        {opts} (sqlite_opts|nil)  see |sqlite_opts|

    Return: ~
        sqlite_db


sqlite.db:extend({opts})                                  *sqlite.db:extend()*
    Extend |sqlite_db| object with extra sugar syntax and api. This is
    recommended for all sqlite use case as it provide convenience. This method
    is super lazy. it try its best to doing any ffi calls until the first
    operation done on a table.

    In the case you want to keep db connection open and not on invocation
    bases. Run |sqlite.db:open()| right after creating the object or when you
    intend,

    ```lua
    local db = sqlite { -- or sqlite_db:extend
      uri = "path/to/db", -- path to db file
      entries = entries,  -- pre-made |etbl| with |tbl:extend()| without db
      category = { title = { "text", unique = true, primary = true}  },
      opts = {} or nil -- custom sqlite3 options, see |sqlite_opts|
    }
    -- unlike |sqlite_tbl|, |sqlite_etbl| is accessed by dot notation.
    db.entries.insert { {..}, {..} }
    ```


    Parameters: ~
        {opts} (table)  see 'Fields'

    Fields: ~
        {uri}    (string)       path to db file.
        {opts}   (sqlite_opts)  (optional) see |sqlite_opts|
        {tname1} (string)       pointing to |sqlite_etbl| or
                                |sqlite_schema_dict|
        {tnameN} (string)       pointing to |sqlite_etbl| or
                                |sqlite_schema_dict|

    Return: ~
        sqlite_db

    See: ~
        |sqlite_tbl:extend()|


sqlite.db:close()                                          *sqlite.db:close()*
    Close sqlite db connection. returns true if closed, error otherwise.

    ```lua
    local db = sqlite.db:open()
    db:close() -- close connection
    ```


    Return: ~
        boolean


sqlite.db:with_open()                                  *sqlite.db:with_open()*
    Same as |sqlite.db:open| but execute {func} then closes db connection. If
    the function is called as a method to db object e.g. 'db:with_open', then
    {args[1]} must be a function. Else {args[1]} need to be the uri and
    {args[2]} the function.

    ```lua
    -- as a function
    local entries = sqlite.with_open("path/to/db", function(db)
       return db:select("todos", { where = { status = "done" } })
    end)
    -- as a method
    local exists = db:with_open(function()
      return db:exists("projects")
     end)
    ```



    Varargs: ~
        If used as db method, then the {args[1]} should be a function, else

    Return: ~
        any

    See: ~
        |sqlite.db:open()|


sqlite.db:isopen()                                        *sqlite.db:isopen()*
    Predict returning true if db connection is active.

    ```lua
    if db:isopen() then
      db:close()
    end
    ```


    Return: ~
        boolean


sqlite.db:isclose()                                      *sqlite.db:isclose()*
    Predict returning true if db connection is indeed closed.

    ```lua
    if db:isclose() then
      error("db is closed")
    end
    ```


    Return: ~
        boolean


sqlite.db:status()                                        *sqlite.db:status()*
    Returns current connection status Get last error code

    ```lua
    print(db:status().msg) -- get last error msg
    print(db:status().code) -- get last error code.
    ```


    Return: ~
        sqlite_db_status


sqlite.db:eval({statement}, {params})                       *sqlite.db:eval()*
    Evaluates a sql {statement} and if there are results from evaluation it
    returns list of rows. Otherwise it returns a boolean indecating whether the
    evaluation was successful.

    ```lua
    -- evaluate without any extra arguments.
    db:eval("drop table if exists todos")
    --  evaluate with unamed value.
    db:eval("select * from todos where id = ?", 1)
    -- evaluate with named arguments.
    db:eval("insert into t(a, b) values(:a, :b)", {a = "1", b = 3})
    ```


    Parameters: ~
        {statement} (string)     SQL statement.
        {params}    (table|nil)  params to be bind to {statement}

    Return: ~
        boolean|table


sqlite.db:execute({statement})                           *sqlite.db:execute()*
    Execute statement without any return

    ```lua
    db:execute("drop table if exists todos")
    db:execute("pragma foreign_keys=on")
    ```


    Parameters: ~
        {statement} (string)  statement to be executed

    Return: ~
        boolean: true if successful, error out if not.


sqlite.db:exists({tbl_name})                              *sqlite.db:exists()*
    Check if a table with {tbl_name} exists in sqlite db
    ```lua
    if not db:exists("todo_tbl") then
      error("Table doesn't exists!!!")
    end
    ```


    Parameters: ~
        {tbl_name} (string)  the table name.

    Return: ~
        boolean


sqlite.db:create({tbl_name}, {schema})                    *sqlite.db:create()*
    Create a new sqlite db table with {name} based on {schema}. if
    {schema.ensure} then create only when it does not exists. similar to
    'create if not exists'.

    ```lua
    db:create("todos", {
      id = {"int", "primary", "key"},
      title = "text",
      name = { type = "string", reference = "sometbl.id" },
      ensure = true -- create table if it doesn't already exists (THIS IS DEFUAULT)
    })
    ```


    Parameters: ~
        {tbl_name} (string)              table name
        {schema}   (sqlite_schema_dict)

    Return: ~
        boolean


sqlite.db:drop({tbl_name})                                  *sqlite.db:drop()*
    Remove {tbl_name} from database

    ```lua
    if db:exists("todos") then
      db:drop("todos")
    end
    ```


    Parameters: ~
        {tbl_name} (string)  table name

    Return: ~
        boolean


sqlite.db:schema({tbl_name})                              *sqlite.db:schema()*
    Get {name} table schema, if table does not exist then return an empty
    table.

    ```lua
    if db:exists("todos") then
      inspect(db:schema("todos").project)
    else
      print("create me")
    end
    ```


    Parameters: ~
        {tbl_name} (string)  the table name.

    Return: ~
        sqlite_schema_dict


sqlite.db:insert({tbl_name}, {rows})                      *sqlite.db:insert()*
    Insert lua table into sqlite database table.

    ```lua
    --- single item.
    db:insert("todos", { title = "new todo" })
    --- insert multiple items.
    db:insert("items", {  { name = "a"}, { name = "b" }, { name = "c" } })
    ```


    Parameters: ~
        {tbl_name} (string)  the table name
        {rows}     (table)   rows to insert to the table.

    Return: ~
        boolean|integer: boolean (true == success), and the last inserted row
        id.


sqlite.db:update({tbl_name}, {specs})                     *sqlite.db:update()*
    Update table row with where closure and list of values returns true incase
    the table was updated successfully.

    ```lua
    --- update todos status linked to project "lua-hello-world" or "rewrite-neoivm-in-rust"
    db:update("todos", {
      where = { project = {"lua-hello-world", "rewrite-neoivm-in-rust"} },
      set = { status = "later" }
    })

    --- pass custom statement and boolean
    db:update("timestamps", {
      where = { id = "<" .. 4 }, -- mimcs WHERE id < 4
      set = { seen = true } -- will be converted to 0.
    })
    ```


    Parameters: ~
        {tbl_name} (string)                                     sqlite table
                                                                name.
        {specs}    (sqlite_query_update|sqlite_query_update[])

    Return: ~
        boolean


sqlite.db:delete({tbl_name}, {where})                     *sqlite.db:delete()*
    Delete a {tbl_name} row/rows based on the {where} closure. If {where ==
    nil} then all the {tbl_name} content will be deleted.

    ```lua
    --- delete todos table content
    db:delete("todos")
    --- delete row that has id as 1
    db:delete("todos", { id = 1 })
    --- delete all rows that has value of id 1 or 2 or 3
    db:delete("todos", { id = {1,2,3} })
    --- matching ids or greater than 5
    db:delete("todos", { id = {"<", 5} }) -- or {id = "<5"}
    ```


    Parameters: ~
        {tbl_name} (string)               sqlite table name
        {where}    (sqlite_query_delete)  key value pair to where delete
                                          operation should effect.

    Return: ~
        boolean: true if operation is successfully, false otherwise.


sqlite.db:select({tbl_name}, {spec})                      *sqlite.db:select()*
    Query from a table with where and join options

    ```lua
    db:select("todos") get everything
    --- get row with id of 1
    db:select("todos", { where = { id = 1 })
    ---  get row with status value of later or paused
    db:select("todos", { where = { status = {"later", "paused"} })
    --- get 5 items from todos table
    db:select("todos", { limit = 5 })
    --- select a set of keys with computed one
    db:select("timestamps", {
      select = {
        age = (strftime("%s", "now") - strftime("%s", "timestamp")) * 24 * 60,
        "id",
        "timestamp",
        "entry",
        },
      })
    ```


    Parameters: ~
        {tbl_name} (string)               the name of the db table to select
                                          on
        {spec}     (sqlite_query_select)

    Return: ~
        table[]


sqlite.db:table({tbl_name}, {opts})                        *sqlite.db:table()*
    Create new sql-table object. WARNING: deprecated use |sqlite.tbl:extend|
    instead. If {opts}.ensure = false, on each run it will drop the table and
    recreate it.
    ```lua
    local tbl = db:table("todos", {
      id = true, -- { type = "integer", required = true, primary = true }
      title = "text",
      since = { "date", default = strftime("%s", "now") },
      count = { "number", default = 0 },
      type = { "text", required = true },
      category = {
        type = "text",
        reference = "category.id",
        on_update = "cascade", -- means when category get updated update
        on_delete = "null", -- means when category get deleted, set to null
      },
    })
    ```


    Parameters: ~
        {tbl_name} (string)  the name of the table. can be new or existing
                             one.
        {opts}     (table)   {schema, ensure (defalut true)}

    Return: ~
        sqlite_tbl


sqlite.db.lib()                                              *sqlite.db.lib()*
    Sqlite functions sugar wrappers. See `sql/strfun`




================================================================================
                                                                    *sqlite.tbl*

Abstraction to produce more readable code.

sqlite.tbl:new({db}, {name}, {schema})                      *sqlite.tbl:new()*
    Create new sql table object WARNING: deprecated use |sqlite.tbl:extend|
    instead.
    ```lua
    local tbl = sqlite.tbl:new(db, "todos", {
      id = true, -- { type = "integer", required = true, primary = true }
      title = "text",
      since = { "date", default = strftime("%s", "now") },
      count = { "number", default = 0 },
      type = { "text", required = true },
      category = {
        type = "text",
        reference = "category.id",
        on_update = "cascade", -- means when category get updated update
        on_delete = "null", -- means when category get deleted, set to null
      },
    })
    ```


    Parameters: ~
        {db}     (sqlite_db)
        {name}   (string)              table name
        {schema} (sqlite_schema_dict)

    Return: ~
        sqlite_tbl


sqlite.tbl:extend({db}, {name}, {schema})                *sqlite.tbl:extend()*
    Same as |sqlite.tbl:new()| but used to extend user defined object. This is
    the recommended way of constructing and using sqlite tables. The only
    difference between this and |sqlite.tbl:new()| or |sqlite.db:table()| is
    the fact that all resulting methods are access using the dot notation '.',
    and when the user overwrites a tbl methods, it gets renamed to
    `_method_name`.

    if first argument is {name} then second should be {schema}. If no {db} is
    provided, the sqlite.tbl object won't be initialized until
    'sqlite.tbl.set_db' is called, thus it can't be defined in different files.

    ```lua
    local t = tbl("entries", { ... } })
    t.insert {...} -- insert rows NOTICE: dot notation
    --- get all entries
    t.get()
    --- Overwrite method name and access original via t._get
    t.get = function() return t._get({ where = {...}, select = {...} })[1] end
    ```


    Parameters: ~
        {db}     (sqlite_db)
        {name}   (string)
        {schema} (sqlite_schema_dict)

    Return: ~
        sqlite_etbl


sqlite.tbl:schema({schema})                              *sqlite.tbl:schema()*
    Create or change table schema. If no {schema} is given, then it return
    current the used schema if it exists or empty table otherwise. On change
    schema it returns boolean indecting success.

    ```lua
    local projects = sqlite.tbl:new("", {...})
    --- get project table schema.
    projects:schema() -- or 'project.schema()' dot notation with |sqlite.tbl:extend|
    --- mutate project table schema with droping content if not schema.ensure
    projects:schema {...} -- or 'project.schema {...}' dot notation with |sqlite.tbl:extend|
    ```


    Parameters: ~
        {schema} (sqlite_schema_dict)

    Return: ~
        sqlite_schema_dict | boolean


sqlite.tbl:drop()                                          *sqlite.tbl:drop()*
    Remove table from database, if the table is already drooped then it returns
    false.

    ```lua
    --- drop todos table content.
    todos:drop() or 'todos.drop()' -- dot notation for |sqlite.tbl:extend|
    ```


    Return: ~
        boolean

    See: ~
        |sqlite.db:drop()|


sqlite.tbl:empty()                                        *sqlite.tbl:empty()*
    Predicate that returns true if the table is empty.

    ```lua
    if todos:empty() then -- or 'todos.emtpy()' for |sqlite.tbl:extend|
      print "no more todos, we are free :D"
    end
    ```


    Return: ~
        boolean


sqlite.tbl:exists()                                      *sqlite.tbl:exists()*
    Predicate that returns true if the table exists.

    ```lua
    if goals:exists() then -- or 'goals.exists()' for |sqlite.tbl:extend|
      error("I'm disappointed in you :D")
    end
    ```


    Return: ~
        boolean


sqlite.tbl:count()                                        *sqlite.tbl:count()*
    Get the current number of rows in the table

    ```lua
    if notes:count() == 0 then -- or 'notes.counts()' for |sqlite.tbl:extend|
      print("no more notes")
    end
    ```


    Return: ~
        number


sqlite.tbl:get({query})                                     *sqlite.tbl:get()*
    Query the table and return results.

    ```lua
    --- get everything
    todos:get() -- or 'todos.get()' with |sqlite.tbl:extend|
    --- get row with id of 1
    todos:get { where = { id = 1 } } -- or 'todos.get { ... }' with |sqlite.tbl:extend|
    --- select a set of keys with computed one
    timestamps:get { -- or 'timestamps.get {... }'  with |sqlite.tbl:extend|
      select = {
        age = (strftime("%s", "now") - strftime("%s", "timestamp")) * 24 * 60,
        "id",
        "timestamp",
        "entry",
        },
      }
    ```


    Parameters: ~
        {query} (sqlite_query_select)

    Return: ~
        table

    See: ~
        |sqlite.db:select()|


sqlite.tbl:where({where})                                 *sqlite.tbl:where()*
    Get first match.

    ```lua
    --- get single entry. notice that we don't pass where key.
    tbl:where{ id = 1 } -- or tbl.where()  with |sqlite.tbl:extend|
    --- get row with id of 1 or 'todos.where { id = 1 }'
    ```


    Parameters: ~
        {where} (table)  where key values

    Return: ~
        nil or row

    Usage: ~
        ``

    See: ~
        |sqlite.db:select()|


sqlite.tbl:each({func}, {query})                           *sqlite.tbl:each()*
    Iterate over table rows and execute {func}. Returns false if no row is
    returned.

    ```lua
    --- Execute a function on each returned row
    todos:each(function(row)
      print(row.title)
    end, {
      where = { status = "pending" },
      contains = { title = "fix*" }
    })
    --- This works too. use 'todos.each(..)' with |sqlite.tbl:extend|
    todos:each({ where = { ... }}, function(row)
      print(row.title)
    end)
    ```


    Parameters: ~
        {func}  (function)                 func(row)
        {query} (sqlite_query_select|nil)

    Return: ~
        boolean


sqlite.tbl:map({func}, {query})                             *sqlite.tbl:map()*
    Create a new table from iterating over a tbl rows with {func}.

    ```lua
    --- transform rows. use todos.map(..) with |sqlite.tbl:extend|
    local rows = todos:map(function(row)
      row.somekey = ""
      row.f = callfunction(row)
      return row
    end, {
      where = { status = "pending" },
      contains = { title = "fix*" }
    })
    --- This works too.
    local titles = todos:map({ where = { ... }}, function(row)
      return row.title
    end)
    --- no query, no problem :D
    local all = todos:map(function(row) return row.title end)
    ```


    Parameters: ~
        {func}  (function)             func(row)
        {query} (sqlite_query_select)

    Return: ~
        table[]


sqlite.tbl:sort({query}, {transform}, {comp})              *sqlite.tbl:sort()*
    Sorts a table in-place using a transform. Values are ranked in a custom
    order of the results of running `transform (v)` on all values. `transform`
    may also be a string name property sort by. `comp` is a comparison
    function. Adopted from Moses.lua

    ```lua
    --- return rows sort by id. t1.sort() with |sqlite.tbl:extend|
    local res = t1:sort({ where = {id = {32,12,35}}})
    --- return rows sort by age
    local res = t1:sort({ where = {id = {32,12,35}}}, "age")`
    --- return with custom sort function (recommended)
    local res = t1:sort({where = { ... }}, "age", function(a, b) return a > b end)`
    ```


    Parameters: ~
        {query}     (sqlite_query_select|nil)
        {transform} (function)                 a `transform` function to sort
                                               elements. Defaults to
                                               @{identity}
        {comp}      (function)                 a comparison function, defaults
                                               to the `<` operator

    Return: ~
        table[]


sqlite.tbl:insert({rows})                                *sqlite.tbl:insert()*
    Insert rows into a table.

    ```lua
    --- single item.
    todos:insert { title = "new todo" }
    --- insert multiple items, using todos table as first param
    tbl.insert(todos, "items", {  { name = "a"}, { name = "b" }, { name = "c" } })
    --- insert with the result of |sqlite.tbl:extend|
    todos.insert { ... }
    ```


    Parameters: ~
        {rows} (table)  a row or a group of rows

    Return: ~
        integer: last inserted id

    Usage: ~
        `todos:insert { title = "stop writing examples :D" }` insert single
        item.
        `todos:insert { { ... }, { ... } }` insert multiple items

    See: ~
        |sqlite.db:insert()|


sqlite.tbl:remove({where})                               *sqlite.tbl:remove()*
    Delete a rows/row or table content based on {where} closure. If {where ==
    nil} then clear table content.

    ```lua
    --- delete todos table content
    todos:remove()
    --- delete row that has id as 1
    todos:remove { id = 1 }
    --- delete all rows that has value of id 1 or 2 or 3
    todos:remove { id = {1,2,3} }
    --- matching ids or greater than 5
    todos:remove { id = {"<", 5} } -- or {id = "<5"}
    --- with |sqtbl:extend|
    todos.remove {...}
    ```


    Parameters: ~
        {where} (sqlite_query_delete)

    Return: ~
        boolean

    See: ~
        |sqlite.db:delete()|


sqlite.tbl:update({specs})                               *sqlite.tbl:update()*
    Update table row with where closure and list of values returns true incase
    the table was updated successfully.

    ```lua
    --- update todos status linked to project "lua-hello-world" or "rewrite-neoivm-in-rust"
    todos:update { -- or 'todos.update { .. }' with the result of |sqlite.tbl:extend|
      where = { project = {"lua-hello-world", "rewrite-neoivm-in-rust"} },
      set = { status = "later" }
    }
    --- pass custom statement and boolean
    ts:update { -- or 'ts.update { .. }' with the result of |sqlite.tbl:extend|
      where = { id = "<" .. 4 }, -- mimcs WHERE id < 4
      set = { seen = true } -- will be converted to 0.
    }
    ```


    Parameters: ~
        {specs} (sqlite_query_update)

    Return: ~
        boolean

    See: ~
        |sqlite.db:update()|
        |sqlite_query_update()|


sqlite.tbl:replace({rows})                              *sqlite.tbl:replace()*
    Replaces table content with a given set of {rows}.

    ```lua
    --- replace project table content with a single call
    todos:replace { -- or 'todos.replace { ... }' with the result |sqlite.tbl:extend|
      { ... },
      { ... },
      { ... },
    }
    --- replace everything with a single row
    ts:replace { -- or 'ts.replace { .. }' with the result |sqlite.tbl:extend|
      key = "val"
    }
    ```


    Parameters: ~
        {rows} (table[]|table)

    Return: ~
        boolean

    See: ~
        |sqlite.db:delete()|
        |sqlite.db:insert()|



 vim:tw=78:ts=8:ft=help:norl:
